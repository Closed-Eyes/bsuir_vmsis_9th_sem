from ComboMaxCover import *
from Globals import *
from LogicElements import *
from SwitchesCalculating import *
from Functions import *

binary = lambda n: n>0 and [n&1]+binary(n>>1) or []

def rotate(l,n):
	return l[-n:] + l[:-n]

def generate_init_states():
	init_states = []
	for i in range(0, 128):
		num_str = bin(i)[2:].zfill(7)

		num_list = [0,0,0,0,0,0,0]
		for j in range(7):
			num_list[j] = int(num_str[j])

		init_states.append(num_list)

	return init_states

def LFSR_next_state(current_state):
	polinom = [1,1,1,1,0,1,1]

	current_state = rotate(current_state, 1)


	result = current_state[0] & polinom[0]
	for i in range(1,7):
		result = result ^ (current_state[i] & polinom[i])

	current_state[0] = result;

	return current_state;


def LFSR_generate_whole_sequence(init_state):

	for i in range(len(init_state)):
		init_state[i] = int(init_state[i])

	sequence = []
	sequence.append(init_state)

	last_element = init_state

	while True:
		last_element = LFSR_next_state(last_element)

		if last_element in sequence:
			break
		else:
			sequence.append(last_element)

	return sequence


def signature_analisator(outputs):
	outputs

init_states = generate_init_states()

characteristics = getTestCover(init_states)
testCover = characteristics[0]
testCoverStat = characteristics[1]

#print init_states

all_results = []

for init_state in init_states:
	sequence = LFSR_generate_whole_sequence(init_state)

	result = getFullCoverCombosForSequence(testCover, testCoverStat, sequence)

	if result != 0:
		#print "Save results"
		all_results.append(result)
		#print result

min_result = all_results[0]
for current_result in all_results:
	if (min_result[1] > current_result[1]):
		min_result = current_result
#print "\nBest result:"
#print min_result

def bin_list(num,bits):
	num_str = bin(i)[2:].zfill(bits)

	num_list = [0]*bits

	for j in range(bits):
		num_list[j] = int(num_str[j])
	return num_list

# SIGNATURE ANALISATOR PART

def zipOutput(scheme_outputs, polinom):
	zipped = [0] * len(polinom)

	for i in range(len(scheme_outputs)):
		zipped = rotate(zipped, 1)


		result = zipped[0] & polinom[0]
		for j in range(1, len(polinom)):
			result = result ^ (zipped[j] & polinom[j])

		zipped[0] = result ^ int(scheme_outputs[i])

# 		print str(zipped), i
	return zipped

# arguments - lists
# return bool True/False
def isSignaturesEqual(correctSignature, testedSignature):
	length = len(correctSignature)
	for index in range(0, length):
		if (correctSignature[index] == testedSignature[index]):
			continue
		else:
			return False
	return True

#signature is list. xors calculated by counting 1 number
def usedXorCount(signature):
	count = 0
	for value in signature:
		if (int(value) == 1):
			count = count + 1
	return count


#getting 127 combos generated by LFSR
sa_input = LFSR_generate_whole_sequence(init_states[1])

# search for minimal sequence that cover all breakings
allTestCombo = generateAllTestCombos()
result = getTestCover(allTestCombo)
testCover = result[0]
testCoverStat = result[1]

sequences = sa_input
min_sequence_count = 127
min_sequence = sa_input
for index in range(1, 128):

	fullCoverCombos = getFullCoverCombosForSequence(testCover, testCoverStat, sequences)
# 	print "counter ", fullCoverCombos[1], " ", min_sequence_count
	if (fullCoverCombos[1] < min_sequence_count):
		min_sequence_count = fullCoverCombos[1]
		min_sequence = fullCoverCombos[0]
	sequences = rotate(sequences, -1)

# right sequence to compare with
correct_outputs = []
for inputs in min_sequence:
	correct_outputs.append(getSchemeOutput(inputs, "R", 0))

#generate incorrect sequences
broken_outputs = dict()
for node_name in GLNodes:
	for brokenType in range(0, 2):
		key = node_name + str(brokenType)
		output_sequence = list()
		for inputs in min_sequence:
			output_sequence.append(getSchemeOutput(inputs, node_name, brokenType))
		print "key ", key, " output ", output_sequence
		broken_outputs[key] = output_sequence


#print all_outputs
all_polynoms = []

for i in range(64,128):
	polynom = bin_list(i,7)
# 	print polynom, " ", i
	all_polynoms.append(polynom)

for i in range(128, 256):
	polynom = bin_list(i, 8)
# 	print polynom, " ", i
	all_polynoms.append(bin_list(i, 8))

for i in range(256, 512):
	polynom = bin_list(i, 8)
# 	print polynom, " ", i
	all_polynoms.append(bin_list(i, 9))

# compare analysis signature for correct scheme and incorrect for each polynom
# save result
polynom_signature = dict()
polynom_result = dict()
polynom_stats = dict()
for polynom in all_polynoms:
	key = listToString(polynom)
	polynom_signature[key] = zipOutput(correct_outputs, polynom)

	found_breaking = 0
	for broken_key, broken_signature in broken_outputs.items():
		zipped_broken = zipOutput(broken_signature, polynom)
# 		print "zipped ", zipped_broken, "polynom", polynom_signature[key]
		if (isSignaturesEqual(polynom_signature[key], zipped_broken) == False):
			found_breaking = found_breaking + 1
	polynom_stats[key] = found_breaking
	print "polynom ", key, " signature ", polynom_signature[key], " result ", polynom_stats[key]*100.0 / 12.0, "%"

min_used_xors = -1
mux_polynom = -1
mux_polynom_signature = -1
for polynom, result in polynom_stats.items():
	polynom_list = getTestInputListFromBinary(polynom)
	current_used_xors = usedXorCount(polynom_list)

	# first item with 100% detecting result
	if (result == 12) and (min_used_xors == -1):
		min_used_xors = current_used_xors
		mux_polynom = polynom
		mux_polynom_signature = polynom_signature[polynom]
	# second and so on 100% results
	else:
		# min count smaller
		if (result == 12) and (current_used_xors < min_used_xors):
			min_used_xors = current_used_xors
			mux_polynom = polynom
			mux_polynom_signature = polynom_signature[polynom]
		else:
			# polynom smaller
			mux_polynom_list = getTestInputListFromBinary(polynom)
			if (result == 12) and (current_used_xors == min_used_xors):
				if len(mux_polynom_list) > len(polynom_list):
					min_used_xors = current_used_xors
					mux_polynom = polynom
					mux_polynom_signature = polynom_signature[polynom]
print "\nBest result:"
print " Used xor: ", min_used_xors, " \n polynom: ", mux_polynom, " \n signature: ", mux_polynom_signature
print " polynom_length: ", len(mux_polynom)